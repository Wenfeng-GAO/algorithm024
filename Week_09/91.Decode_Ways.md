# 91. 解码方法

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"111" 可以将 "1" 中的每个 "1" 映射为 "A" ，从而得到 "AAA" ，或者可以将 "11" 和 "1"（分别为 "K" 和 "A" ）映射为 "KA" 。注意，"06" 不能映射为 "F" ，因为 "6" 和 "06" 不同。

给你一个只含数字的 非空 字符串 num ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

 

示例 1：
```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

## 题解
### DP
复杂度分析：
- time: O(len(s))
- space: O(1)

```go
func numDecodings(s string) int {
    if s[0] == '0' {
        return 0
    }
    // n: 当前编码个数
    // n1: s[i-1]为止的编码个数
    // n2: s[i-2]为止的编码个数
    n, n1, n2 := 1, 1, 1
    for i := 1; i < len(s); i++ {
        if s[i] == '0' {
            // 当s[i] == 0时，提前判断合法性
            // 此时s[i]只能依附s[i-1]才合法， n=n2
            if s[i-1] != '1' && s[i-1] != '2' {
                return 0
            }
            n = n2

        } else {
            // s[i]不为0，首先s[i]可以独立编码 n = n1
            n = n1

            // 其次，当可以依附s[i-1]时，又多出了编码方式，n+=n2
            if s[i-1] == '1' || (s[i-1] == '2' && '1' <= s[i] && s[i] <= '6') {
                n += n2
            }
        }
        n2, n1 = n1, n
    }
    return n
}
```
